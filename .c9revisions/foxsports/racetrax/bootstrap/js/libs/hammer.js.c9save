{"ts":1357814111160,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n * Hammer.JS\n * version 0.6.4\n * author: Eight Media\n * https://github.com/EightMedia/hammer.js\n * Licensed under the MIT license.\n */\nfunction Hammer(element, options, undefined)\n{\n    var self = this;\n\n    var defaults = mergeObject({\n        // prevent the default event or not... might be buggy when false\n        prevent_default    : false,\n        css_hacks          : true,\n\n        swipe              : true,\n        swipe_time         : 200,   // ms\n        swipe_min_distance : 20,   // pixels\n\n        drag               : true,\n        drag_vertical      : true,\n        drag_horizontal    : true,\n        // minimum distance before the drag event starts\n        drag_min_distance  : 20,    // pixels\n\n        // pinch zoom and rotation\n        transform          : true,\n        scale_treshold     : 0.1,\n        rotation_treshold  : 15,    // degrees\n\n        tap                : true,\n        tap_double         : true,\n        tap_max_interval   : 300,\n        tap_max_distance   : 10,\n        tap_double_distance: 20,\n\n        hold               : true,\n        hold_timeout       : 500\n    }, Hammer.defaults || {});\n    options = mergeObject(defaults, options);\n\n    // some css hacks\n    (function() {\n        if(!options.css_hacks) {\n            return false;\n        }\n\n        var vendors = ['webkit','moz','ms','o',''];\n        var css_props = {\n            \"userSelect\": \"none\",\n            \"touchCallout\": \"none\",\n            \"userDrag\": \"none\",\n            \"tapHighlightColor\": \"rgba(0,0,0,0)\"\n        };\n\n        var prop = '';\n        for(var i = 0; i < vendors.length; i++) {\n            for(var p in css_props) {\n                prop = p;\n                if(vendors[i]) {\n                    prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n                }\n                element.style[ prop ] = css_props[p];\n            }\n        }\n    })();\n\n    // holds the distance that has been moved\n    var _distance = 0;\n\n    // holds the exact angle that has been moved\n    var _angle = 0;\n\n    // holds the direction that has been moved\n    var _direction = 0;\n\n    // holds position movement for sliding\n    var _pos = { };\n\n    // how many fingers are on the screen\n    var _fingers = 0;\n\n    var _first = false;\n\n    var _gesture = null;\n    var _prev_gesture = null;\n\n    var _touch_start_time = null;\n    var _prev_tap_pos = {x: 0, y: 0};\n    var _prev_tap_end_time = null;\n\n    var _hold_timer = null;\n\n    var _offset = {};\n\n    // keep track of the mouse status\n    var _mousedown = false;\n\n    var _event_start;\n    var _event_move;\n    var _event_end;\n\n    var _has_touch = ('ontouchstart' in window);\n\n    var _can_tap = false;\n\n\n    /**\n     * option setter/getter\n     * @param   string  key\n     * @param   mixed   value\n     * @return  mixed   value\n     */\n    this.option = function(key, val) {\n        if(val !== undefined) {\n            options[key] = val;\n        }\n\n        return options[key];\n    };\n\n\n    /**\n     * angle to direction define\n     * @param  float    angle\n     * @return string   direction\n     */\n    this.getDirectionFromAngle = function( angle ) {\n        var directions = {\n            down: angle >= 45 && angle < 135, //90\n            left: angle >= 135 || angle <= -135, //180\n            up: angle < -45 && angle > -135, //270\n            right: angle >= -45 && angle <= 45 //0\n        };\n\n        var direction, key;\n        for(key in directions){\n            if(directions[key]){\n                direction = key;\n                break;\n            }\n        }\n        return direction;\n    };\n\n\n    /**\n     * destroy events\n     * @return  void\n     */\n    this.destroy = function() {\n        if(_has_touch) {\n            removeEvent(element, \"touchstart touchmove touchend touchcancel\", handleEvents);\n        }\n        // for non-touch\n        else {\n            removeEvent(element, \"mouseup mousedown mousemove\", handleEvents);\n            removeEvent(element, \"mouseout\", handleMouseOut);\n        }\n    };\n\n\n    /**\n     * count the number of fingers in the event\n     * when no fingers are detected, one finger is returned (mouse pointer)\n     * @param  event\n     * @return int  fingers\n     */\n    function countFingers( event )\n    {\n        // there is a bug on android (until v4?) that touches is always 1,\n        // so no multitouch is supported, e.g. no, zoom and rotation...\n        return event.touches ? event.touches.length : 1;\n    }\n\n\n    /**\n     * get the x and y positions from the event object\n     * @param  event\n     * @return array  [{ x: int, y: int }]\n     */\n    function getXYfromEvent( event )\n    {\n        event = event || window.event;\n\n        // no touches, use the event pageX and pageY\n        if(!_has_touch) {\n            var doc = document,\n                body = doc.body;\n\n            return [{\n                x: event.pageX || event.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && doc.clientLeft || 0 ),\n                y: event.pageY || event.clientY + ( doc && doc.scrollTop || body && body.scrollTop || 0 ) - ( doc && doc.clientTop || body && doc.clientTop || 0 )\n            }];\n        }\n        // multitouch, return array with positions\n        else {\n            var pos = [], src;\n            for(var t=0, len=event.touches.length; t<len; t++) {\n                src = event.touches[t];\n                pos.push({ x: src.pageX, y: src.pageY });\n            }\n            return pos;\n        }\n    }\n\n\n    /**\n     * calculate the angle between two points\n     * @param   object  pos1 { x: int, y: int }\n     * @param   object  pos2 { x: int, y: int }\n     */\n    function getAngle( pos1, pos2 )\n    {\n        return Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x) * 180 / Math.PI;\n    }\n\n    /**\n     * calculate the distance between two points\n     * @param   object  pos1 { x: int, y: int }\n     * @param   object  pos2 { x: int, y: int }\n     */\n    function getDistance( pos1, pos2 )\n    {\n        var x = pos2.x - pos1.x, y = pos2.y - pos1.y;\n        return Math.sqrt((x * x) + (y * y));\n    }\n\n\n    /**\n     * calculate the scale size between two fingers\n     * @param   object  pos_start\n     * @param   object  pos_move\n     * @return  float   scale\n     */\n    function calculateScale(pos_start, pos_move)\n    {\n        if(pos_start.length == 2 && pos_move.length == 2) {\n            var start_distance = getDistance(pos_start[0], pos_start[1]);\n            var end_distance = getDistance(pos_move[0], pos_move[1]);\n            return end_distance / start_distance;\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * calculate the rotation degrees between two fingers\n     * @param   object  pos_start\n     * @param   object  pos_move\n     * @return  float   rotation\n     */\n    function calculateRotation(pos_start, pos_move)\n    {\n        if(pos_start.length == 2 && pos_move.length == 2) {\n            var start_rotation = getAngle(pos_start[1], pos_start[0]);\n            var end_rotation = getAngle(pos_move[1], pos_move[0]);\n            return end_rotation - start_rotation;\n        }\n\n        return 0;\n    }\n\n\n    /**\n     * trigger an event/callback by name with params\n     * @param string name\n     * @param array  params\n     */\n    function triggerEvent( eventName, params )\n    {\n        // return touches object\n        params.touches = getXYfromEvent(params.originalEvent);\n        params.type = eventName;\n\n        // trigger callback\n        if(isFunction(self[\"on\"+ eventName])) {\n            self[\"on\"+ eventName].call(self, params);\n        }\n    }\n\n\n    /**\n     * cancel event\n     * @param   object  event\n     * @return  void\n     */\n\n    function cancelEvent(event)\n    {\n        event = event || window.event;\n        if(event.preventDefault){\n            event.preventDefault();\n            event.stopPropagation();\n        }else{\n            event.returnValue = false;\n            event.cancelBubble = true;\n        }\n    }\n\n\n    /**\n     * reset the internal vars to the start values\n     */\n    function reset()\n    {\n        _pos = {};\n        _first = false;\n        _fingers = 0;\n        _distance = 0;\n        _angle = 0;\n        _gesture = null;\n    }\n\n\n    var gestures = {\n        // hold gesture\n        // fired on touchstart\n        hold : function(event)\n        {\n            // only when one finger is on the screen\n            if(options.hold) {\n                _gesture = 'hold';\n                clearTimeout(_hold_timer);\n\n                _hold_timer = setTimeout(function() {\n                    if(_gesture == 'hold') {\n                        triggerEvent(\"hold\", {\n                            originalEvent   : event,\n                            position        : _pos.start\n                        });\n                    }\n                }, options.hold_timeout);\n            }\n        },\n\n        // swipe gesture\n        // fired on touchend\n        swipe : function(event)\n        {\n            if (!_pos.move || _gesture === \"transform\") {\n                return;\n            }\n\n            // get the distance we moved\n            var _distance_x = _pos.move[0].x - _pos.start[0].x;\n            var _distance_y = _pos.move[0].y - _pos.start[0].y;\n            _distance = Math.sqrt(_distance_x*_distance_x + _distance_y*_distance_y);\n\n            // compare the kind of gesture by time\n            var now = new Date().getTime();\n            var touch_time = now - _touch_start_time;\n\n            if(options.swipe && (options.swipe_time > touch_time) && (_distance > options.swipe_min_distance)) {\n                // calculate the angle\n                _angle = getAngle(_pos.start[0], _pos.move[0]);\n                _direction = self.getDirectionFromAngle(_angle);\n\n                _gesture = 'swipe';\n\n                var position = { x: _pos.move[0].x - _offset.left,\n                    y: _pos.move[0].y - _offset.top };\n\n                var event_obj = {\n                    originalEvent   : event,\n                    position        : position,\n                    direction       : _direction,\n                    distance        : _distance,\n                    distanceX       : _distance_x,\n                    distanceY       : _distance_y,\n                    angle           : _angle\n                };\n\n                // normal slide event\n                triggerEvent(\"swipe\", event_obj);\n            }\n        },\n\n\n        // drag gesture\n        // fired on mousemove\n        drag : function(event)\n        {\n            // get the distance we moved\n            var _distance_x = _pos.move[0].x - _pos.start[0].x;\n            var _distance_y = _pos.move[0].y - _pos.start[0].y;\n            _distance = Math.sqrt(_distance_x * _distance_x + _distance_y * _distance_y);\n\n            // drag\n            // minimal movement required\n            if(options.drag && (_distance > options.drag_min_distance) || _gesture == 'drag') {\n                // calculate the angle\n                _angle = getAngle(_pos.start[0], _pos.move[0]);\n                _direction = self.getDirectionFromAngle(_angle);\n\n                // check the movement and stop if we go in the wrong direction\n                var is_vertical = (_direction == 'up' || _direction == 'down');\n\n                if(((is_vertical && !options.drag_vertical) || (!is_vertical && !options.drag_horizontal)) && (_distance > options.drag_min_distance)) {\n                    return;\n                }\n\n                _gesture = 'drag';\n\n                var position = { x: _pos.move[0].x - _offset.left,\n                    y: _pos.move[0].y - _offset.top };\n\n                var event_obj = {\n                    originalEvent   : event,\n                    position        : position,\n                    direction       : _direction,\n                    distance        : _distance,\n                    distanceX       : _distance_x,\n                    distanceY       : _distance_y,\n                    angle           : _angle\n                };\n\n                // on the first time trigger the start event\n                if(_first) {\n                    triggerEvent(\"dragstart\", event_obj);\n\n                    _first = false;\n                }\n\n                // normal slide event\n                triggerEvent(\"drag\", event_obj);\n\n                cancelEvent(event);\n            }\n        },\n\n\n        // transform gesture\n        // fired on touchmove\n        transform : function(event)\n        {\n            if(options.transform) {\n                var count = countFingers(event);\n                if (count !== 2) {\n                    return false;\n                }\n\n                var rotation = calculateRotation(_pos.start, _pos.move);\n                var scale = calculateScale(_pos.start, _pos.move);\n\n                if (_gesture === 'transform' ||\n                    Math.abs(1 - scale) > options.scale_treshold ||\n                    Math.abs(rotation) > options.rotation_treshold) {\n\n                    _gesture = 'transform';\n                    _pos.center = {\n                        x: ((_pos.move[0].x + _pos.move[1].x) / 2) - _offset.left,\n                        y: ((_pos.move[0].y + _pos.move[1].y) / 2) - _offset.top\n                    };\n\n                    if(_first)\n                        _pos.startCenter = _pos.center;\n\n                    var _distance_x = _pos.center.x - _pos.startCenter.x;\n                    var _distance_y = _pos.center.y - _pos.startCenter.y;\n                    _distance = Math.sqrt(_distance_x*_distance_x + _distance_y*_distance_y);\n\n                    var event_obj = {\n                        originalEvent   : event,\n                        position        : _pos.center,\n                        scale           : scale,\n                        rotation        : rotation,\n                        distance        : _distance,\n                        distanceX       : _distance_x,\n                        distanceY       : _distance_y\n                    };\n\n                    // on the first time trigger the start event\n                    if (_first) {\n                        triggerEvent(\"transformstart\", event_obj);\n                        _first = false;\n                    }\n\n                    triggerEvent(\"transform\", event_obj);\n\n                    cancelEvent(event);\n\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n\n        // tap and double tap gesture\n        // fired on touchend\n        tap : function(event)\n        {\n            // compare the kind of gesture by time\n            var now = new Date().getTime();\n            var touch_time = now - _touch_start_time;\n\n            // dont fire when hold is fired\n            if(options.hold && !(options.hold && options.hold_timeout > touch_time)) {\n                return;\n            }\n\n            // when previous event was tap and the tap was max_interval ms ago\n            var is_double_tap = (function(){\n                if (_prev_tap_pos &&\n                    options.tap_double &&\n                    _prev_gesture == 'tap' &&\n                    _pos.start &&\n                    (_touch_start_time - _prev_tap_end_time) < options.tap_max_interval)\n                {\n                    var x_distance = Math.abs(_prev_tap_pos[0].x - _pos.start[0].x);\n                    var y_distance = Math.abs(_prev_tap_pos[0].y - _pos.start[0].y);\n                    return (_prev_tap_pos && _pos.start && Math.max(x_distance, y_distance) < options.tap_double_distance);\n                }\n                return false;\n            })();\n\n            if(is_double_tap) {\n                _gesture = 'double_tap';\n                _prev_tap_end_time = null;\n\n                triggerEvent(\"doubletap\", {\n                    originalEvent   : event,\n                    position        : _pos.start\n                });\n                cancelEvent(event);\n            }\n\n            // single tap is single touch\n            else {\n                var x_distance = (_pos.move) ? Math.abs(_pos.move[0].x - _pos.start[0].x) : 0;\n                var y_distance =  (_pos.move) ? Math.abs(_pos.move[0].y - _pos.start[0].y) : 0;\n                _distance = Math.max(x_distance, y_distance);\n\n                if(_distance < options.tap_max_distance) {\n                    _gesture = 'tap';\n                    _prev_tap_end_time = now;\n                    _prev_tap_pos = _pos.start;\n\n                    if(options.tap) {\n                        triggerEvent(\"tap\", {\n                            originalEvent   : event,\n                            position        : _pos.start\n                        });\n                        cancelEvent(event);\n                    }\n                }\n            }\n        }\n    };\n\n\n    function handleEvents(event)\n    {\n        var count;\n        switch(event.type)\n        {\n            case 'mousedown':\n            case 'touchstart':\n                count = countFingers(event);\n                _can_tap = count === 1;\n\n                //We were dragging and now we are zooming.\n                if (count === 2 && _gesture === \"drag\") {\n\n                    //The user needs to have the dragend to be fired to ensure that\n                    //there is proper cleanup from the drag and move onto transforming.\n                    triggerEvent(\"dragend\", {\n                        originalEvent   : event,\n                        direction       : _direction,\n                        distance        : _distance,\n                        angle           : _angle\n                    });\n                }\n                _setup();\n\n                if(options.prevent_default) {\n                    cancelEvent(event);\n                }\n                break;\n\n            case 'mousemove':\n            case 'touchmove':\n                count = countFingers(event);\n\n                //The user has gone from transforming to dragging.  The\n                //user needs to have the proper cleanup of the state and\n                //setup with the new \"start\" points.\n                if (!_mousedown && count === 1) {\n                    return false;\n                } else if (!_mousedown && count === 2) {\n                    _can_tap = false;\n\n                    reset();\n                    _setup();\n                }\n\n                _event_move = event;\n                _pos.move = getXYfromEvent(event);\n\n                if(!gestures.transform(event)) {\n                    gestures.drag(event);\n                }\n                break;\n\n            case 'mouseup':\n            case 'mouseout':\n            case 'touchcancel':\n            case 'touchend':\n                var callReset = true;\n\n                _mousedown = false;\n                _event_end = event;\n\n                // swipe gesture\n                gestures.swipe(event);\n\n                // drag gesture\n                // dragstart is triggered, so dragend is possible\n                if(_gesture == 'drag') {\n                    triggerEvent(\"dragend\", {\n                        originalEvent   : event,\n                        direction       : _direction,\n                        distance        : _distance,\n                        angle           : _angle\n                    });\n                }\n\n                // transform\n                // transformstart is triggered, so transformed is possible\n                else if(_gesture == 'transform') {\n                    // define the transform distance\n                    var _distance_x = _pos.center.x - _pos.startCenter.x;\n                    var _distance_y = _pos.center.y - _pos.startCenter.y;\n                    \n                    triggerEvent(\"transformend\", {\n                        originalEvent   : event,\n                        position        : _pos.center,\n                        scale           : calculateScale(_pos.start, _pos.move),\n                        rotation        : calculateRotation(_pos.start, _pos.move),\n                        distance        : _distance,\n                        distanceX       : _distance_x,\n                        distanceY       : _distance_y\n                    });\n\n                    //If the user goes from transformation to drag there needs to be a\n                    //state reset so that way a dragstart/drag/dragend will be properly\n                    //fired.\n                    if (countFingers(event) === 1) {\n                        reset();\n                        _setup();\n                        callReset = false;\n                    }\n                } else if (_can_tap) {\n                    gestures.tap(_event_start);\n                }\n\n                _prev_gesture = _gesture;\n\n                // trigger release event\n                // \"release\" by default doesn't return the co-ords where your\n                // finger was released. \"position\" will return \"the last touched co-ords\"\n\n                triggerEvent(\"release\", {\n                    originalEvent   : event,\n                    gesture         : _gesture,\n                    position        : _pos.move || _pos.start\n                });\n\n                // reset vars if this was not a transform->drag touch end operation.\n                if (callReset) {\n                    reset();\n                }\n                break;\n        } // end switch\n\n        /**\n         * Performs a blank setup.\n         * @private\n         */\n        function _setup() {\n            _pos.start = getXYfromEvent(event);\n            _touch_start_time = new Date().getTime();\n            _fingers = countFingers(event);\n            _first = true;\n            _event_start = event;\n\n            // borrowed from jquery offset https://github.com/jquery/jquery/blob/master/src/offset.js\n            var box = element.getBoundingClientRect();\n            var clientTop  = element.clientTop  || document.body.clientTop  || 0;\n            var clientLeft = element.clientLeft || document.body.clientLeft || 0;\n            var scrollTop  = window.pageYOffset || element.scrollTop  || document.body.scrollTop;\n            var scrollLeft = window.pageXOffset || element.scrollLeft || document.body.scrollLeft;\n\n            _offset = {\n                top: box.top + scrollTop - clientTop,\n                left: box.left + scrollLeft - clientLeft\n            };\n\n            _mousedown = true;\n\n            // hold gesture\n            gestures.hold(event);\n        }\n    }\n\n\n    function handleMouseOut(event) {\n        if(!isInsideHammer(element, event.relatedTarget)) {\n            handleEvents(event);\n        }\n    }\n\n\n    // bind events for touch devices\n    // except for windows phone 7.5, it doesnt support touch events..!\n    if(_has_touch) {\n        addEvent(element, \"touchstart touchmove touchend touchcancel\", handleEvents);\n    }\n    // for non-touch\n    else {\n        addEvent(element, \"mouseup mousedown mousemove\", handleEvents);\n        addEvent(element, \"mouseout\", handleMouseOut);\n    }\n\n\n    /**\n     * find if element is (inside) given parent element\n     * @param   object  element\n     * @param   object  parent\n     * @return  bool    inside\n     */\n    function isInsideHammer(parent, child) {\n        // get related target for IE\n        if(!child && window.event && window.event.toElement){\n            child = window.event.toElement;\n        }\n\n        if(parent === child){\n            return true;\n        }\n\n        // loop over parentNodes of child until we find hammer element\n        if(child){\n            var node = child.parentNode;\n            while(node !== null){\n                if(node === parent){\n                    return true;\n                }\n                node = node.parentNode;\n            }\n        }\n        return false;\n    }\n\n\n    /**\n     * merge 2 objects into a new object\n     * @param   object  obj1\n     * @param   object  obj2\n     * @return  object  merged object\n     */\n    function mergeObject(obj1, obj2) {\n        var output = {};\n\n        if(!obj2) {\n            return obj1;\n        }\n\n        for (var prop in obj1) {\n            if (prop in obj2) {\n                output[prop] = obj2[prop];\n            } else {\n                output[prop] = obj1[prop];\n            }\n        }\n        return output;\n    }\n\n\n    /**\n     * check if object is a function\n     * @param   object  obj\n     * @return  bool    is function\n     */\n    function isFunction( obj ){\n        return Object.prototype.toString.call( obj ) == \"[object Function]\";\n    }\n\n\n    /**\n     * attach event\n     * @param   node    element\n     * @param   string  types\n     * @param   object  callback\n     */\n    function addEvent(element, types, callback) {\n        types = types.split(\" \");\n        for(var t= 0,len=types.length; t<len; t++) {\n            if(element.addEventListener){\n                element.addEventListener(types[t], callback, false);\n            }\n            else if(document.attachEvent){\n                element.attachEvent(\"on\"+ types[t], callback);\n            }\n        }\n    }\n\n\n    /**\n     * detach event\n     * @param   node    element\n     * @param   string  types\n     * @param   object  callback\n     */\n    function removeEvent(element, types, callback) {\n        types = types.split(\" \");\n        for(var t= 0,len=types.length; t<len; t++) {\n            if(element.removeEventListener){\n                element.removeEventListener(types[t], callback, false);\n            }\n            else if(document.detachEvent){\n                element.detachEvent(\"on\"+ types[t], callback);\n            }\n        }\n    }\n}"]],"start1":0,"start2":0,"length1":0,"length2":25570}]],"length":25570}
